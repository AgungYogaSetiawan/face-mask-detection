# -*- coding: utf-8 -*-
"""Face Mask Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
https://colab.research.google.com/drive/1YjVIiv5Am5tLOPOokay9dXXTLBRYc9da#scrollTo=p5_UjV7Ah6jw&uniqifier=2

### Import Required Dependencies
"""

import tensorflow as tf
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import os
import cv2
import streamlit as st
import snapshot as snap
from PIL import Image
from tensorflow.keras import models, layers
from keras.models import load_model

IMAGE_SIZE = 256
BATCH_SIZE = 32
CHANNELS = 3

dataset = tf.keras.preprocessing.image_dataset_from_directory(
    './datasets2',
    batch_size=BATCH_SIZE,
    image_size=(IMAGE_SIZE, IMAGE_SIZE),
    seed=123,
    shuffle=True
)

class_names = dataset.class_names

"""### Build Web App Using Streamlit"""

@st.cache(allow_output_mutation=True)
def load_model():
  model=tf.keras.models.load_model('model.hdf5')
  return model
model=load_model()

st.write("""
# Face Mask Detection Web App with Streamlit
"""
)

# camera_input = st.camera_input("Take a picture")
# st.set_option('deprecation.showfileUploaderEncoding', False)

# function to predict image
def take_and_predict(image, model):
    # img_array = tf.keras.preprocessing.image.img_to_array(image)
    # img_array = tf.expand_dims(img_array, 0)
    predictions = model.predict(image)
    predicted_class = class_names[np.argmax(predictions[0])]
    score = round(100 * (np.max(predictions[0])), 2)
    
    return predicted_class, score

# option selectbox
option = st.selectbox(
        'Please select photo input type',
        ('Take photo', 'Upload photo'))

if option == 'Take photo':
    # In case Take photo is selected, run the webrtc component, 
    # save photo and pass it to the object detection model
    out_image = snap.streamlit_webrtc_snapshot()
    
    if out_image is not None:
        st.image(out_image, channels="BGR")
        img = cv2.resize(out_image, (256,256))
        img = np.reshape(img, [1,256,256,3])
        predicted_class, score = take_and_predict(img, model)
        st.write(f'This image most likely belongs to {predicted_class} with a {score} % confidence.')
    else:
        st.warning('Waiting for snapshot to be taken')

elif option == 'Upload photo':
    file = st.file_uploader("Please upload an file image", type=["jpg", "png", "jpeg"])
    st.set_option('deprecation.showfileUploaderEncoding', False)
        
    if file is not None:
        
        # with open(os.path.join("tempDir",file.name),"wb") as f: 
        #     f.write(file.getbuffer()) 
        image = Image.open(file)
        st.image(image, use_column_width=True)
        img_array = tf.keras.preprocessing.image.img_to_array(image)
        img_array = tf.expand_dims(img_array, 0)
        predicted_class, score = take_and_predict(img_array, model)
        st.write(f'This image most likely belongs to {predicted_class} with a {score} % confidence.')
        
else:
    st.warning('Please select the type of photo you would like to classify.')


