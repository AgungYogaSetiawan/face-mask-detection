# -*- coding: utf-8 -*-
"""Face Mask Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
https://colab.research.google.com/drive/1YjVIiv5Am5tLOPOokay9dXXTLBRYc9da#scrollTo=p5_UjV7Ah6jw&uniqifier=2

### Import Required Dependencies
"""

import tensorflow as tf
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import os
import cv2
import streamlit as st
import snapshot as snap
import time 
from datetime import date
from PIL import Image
from tensorflow.keras import models, layers
from keras.models import load_model

IMAGE_SIZE = 256
BATCH_SIZE = 32
CHANNELS = 3

dataset = tf.keras.preprocessing.image_dataset_from_directory(
    './datasets2',
    batch_size=BATCH_SIZE,
    image_size=(IMAGE_SIZE, IMAGE_SIZE),
    seed=123,
    shuffle=True
)

class_names = dataset.class_names
st.set_page_config(page_title='Face Mask Detection Web App with Streamlit',layout='wide', page_icon=":mask:")
"""### Build Web App Using Streamlit"""
# page layout menjadi wide

# function to load model
@st.cache(allow_output_mutation=True)
def load_model():
    model=tf.keras.models.load_model('model_V4.hdf5')
    return model

model = load_model()

st.write("""
# :mask: Face Mask Detection Web App with Streamlit
"""
)

# function to predict image
def take_and_predict(image, model):
    predictions = model.predict(image)
    predicted_class = class_names[np.argmax(predictions[0])]
    score = round(100 * (np.max(predictions[0])), 2)
    
    return predicted_class, score

# function to write image to folder tempDir with unique name
def write_image(out_image):
    '''
    Write image to tempDir folder with a unique name
    '''
    
    today = date.today()
    d = today.strftime("%b-%d-%Y")
    
    t = time.localtime()
    current_time = time.strftime("%H-%M-%S", t)
    
    file_name = "tempDir/photo_" + d + "_" + current_time + ".jpg"
    
    cv2.imwrite(file_name, out_image)
    
    return(file_name)

# option selectbox
option = st.selectbox(
        'Please select photo input type',
        ('Take photo', 'Upload photo'))

if option == 'Take photo':
    # In case Take photo is selected, run the webrtc component, 
    # save photo and pass it to the object detection model
    out_image = snap.streamlit_webrtc_snapshot()
    
    if out_image is not None:
        st.image(out_image, channels="BGR") # display image
        img = cv2.resize(out_image, (256,256)) # resizing image
        img = np.reshape(img, [1,256,256,3]) # reshape image to easy to predict same like train image
        # file_name = write_image(img) # write image to folder tempDir
        predicted_class, score = take_and_predict(img, model) # results
        st.write(f'This image most likely belongs to {predicted_class} with a {score} % confidence.')
    else:
        st.warning('Waiting for snapshot to be taken')

elif option == 'Upload photo':
    file = st.file_uploader("Please upload an file image", type=["jpg", "png", "jpeg"])
    st.set_option('deprecation.showfileUploaderEncoding', False)
        
    if file is not None:
        
        # with open(os.path.join("tempDir",file.name),"wb") as f: 
        #     f.write(file.getbuffer()) # write image to folder tempDir
        image = Image.open(file)
        st.image(image, use_column_width=True)
        img_array = tf.keras.preprocessing.image.img_to_array(image)
        img_array = tf.expand_dims(img_array, 0)
        predicted_class, score = take_and_predict(img_array, model)
        st.write(f'This image most likely belongs to {predicted_class} with a {score} % confidence.')
        
else:
    st.warning('Please select the type of photo you would like to classify.')


